//! Diagnostics related to parsing

const std = @import("std");
const base = @import("../../base.zig");
const reporting = @import("../../reporting.zig");
const AST = @import("AST.zig");

const Region = base.Region;

tag: Tag,
region: AST.TokenizedRegion,

/// different types of diagnostic errors
pub const Tag = enum {
    bad_indent,
    multiple_platforms,
    no_platform,
    missing_header,
    list_not_closed,
    missing_arrow,
    expected_exposes,
    expected_exposes_close_square,
    expected_exposes_open_square,
    expected_imports,
    expected_imports_close_curly,
    expected_imports_open_curly,
    expected_package_or_platform_name,
    expected_package_or_platform_colon,
    expected_package_or_platform_string,
    expected_package_platform_close_curly,
    expected_package_platform_open_curly,
    expected_packages,
    expected_packages_close_curly,
    expected_packages_open_curly,
    expected_platform_name_end,
    expected_platform_name_start,
    expected_platform_name_string,
    expected_platform_string,
    expected_provides,
    expected_provides_close_square,
    expected_provides_open_square,
    expected_requires,
    expected_requires_rigids_close_curly,
    expected_requires_rigids_open_curly,
    expected_requires_signatures_close_curly,
    expected_requires_signatures_open_curly,
    expect_closing_paren,
    header_expected_open_square,
    header_expected_close_square,
    header_unexpected_token,
    pattern_unexpected_token,
    pattern_unexpected_eof,
    ty_anno_unexpected_token,
    statement_unexpected_eof,
    statement_unexpected_token,
    string_unexpected_token,
    string_expected_close_interpolation,
    expr_if_missing_else,
    expr_no_space_dot_int,
    import_exposing_no_open,
    import_exposing_no_close,
    no_else,
    expected_type_field_name,
    expected_colon_after_type_field_name,
    expected_arrow,
    expected_ty_close_curly_or_comma,
    expected_ty_close_square_or_comma,
    expected_lower_name_after_exposed_item_as,
    expected_upper_name_after_exposed_item_as,
    exposed_item_unexpected_token,
    expected_upper_name_after_import_as,
    expected_colon_after_type_annotation,
    expected_lower_ident_pat_field_name,
    expected_colon_after_pat_field_name,
    expected_expr_bar,
    expected_expr_close_curly_or_comma,
    expected_expr_close_round_or_comma,
    expected_expr_close_square_or_comma,
    expected_close_curly_at_end_of_match,
    expected_open_curly_after_match,
    expr_unexpected_token,
    expected_expr_record_field_name,
    expected_ty_apply_close_round,
    expected_ty_anno_end_of_function,
    expected_ty_anno_end,
    expected_expr_apply_close_round,
    where_expected_where,
    where_expected_mod_open,
    where_expected_var,
    where_expected_mod_close,
    where_expected_arg_open,
    where_expected_arg_close,
    where_expected_method_arrow,
    where_expected_method_or_alias_name,
    where_expected_var_or_module,
    import_must_be_top_level,
    invalid_type_arg,
    expr_arrow_expects_ident,
    var_only_allowed_in_a_body,
    var_must_have_ident,
    var_expected_equals,
    for_expected_in,
};

/// Convert this diagnostic to a Report for rendering
pub fn toReport(self: @This(), allocator: std.mem.Allocator, _: []const u8) !reporting.Report {
    const message = switch (self.tag) {
        .bad_indent => "Bad indentation",
        .multiple_platforms => "Multiple platform declarations found",
        .no_platform => "No platform declaration found",
        .missing_header => "Missing header",
        .list_not_closed => "List not properly closed",
        .missing_arrow => "Missing arrow",
        .expected_exposes => "Expected 'exposes'",
        .expected_exposes_close_square => "Expected ']' after exposes",
        .expected_exposes_open_square => "Expected '[' after exposes",
        .expected_imports => "Expected 'imports'",
        .expected_imports_close_curly => "Expected '}' after imports",
        .expected_imports_open_curly => "Expected '{' after imports",
        .expected_package_or_platform_name => "Expected package or platform name",
        .expected_package_or_platform_colon => "Expected ':' after package or platform name",
        .expected_package_or_platform_string => "Expected string after package or platform",
        .expected_package_platform_close_curly => "Expected '}' after package platform",
        .expected_package_platform_open_curly => "Expected '{' after package platform",
        .expected_packages => "Expected 'packages'",
        .expected_packages_close_curly => "Expected '}' after packages",
        .expected_packages_open_curly => "Expected '{' after packages",
        .expected_platform_name_end => "Expected end of platform name",
        .expected_platform_name_start => "Expected start of platform name",
        .expected_platform_name_string => "Expected platform name string",
        .expected_platform_string => "Expected platform string",
        .expected_provides => "Expected 'provides'",
        .expected_provides_close_square => "Expected ']' after provides",
        .expected_provides_open_square => "Expected '[' after provides",
        .expected_requires => "Expected 'requires'",
        .expected_requires_rigids_close_curly => "Expected '}' after requires rigids",
        .expected_requires_rigids_open_curly => "Expected '{' after requires rigids",
        .expected_requires_signatures_close_curly => "Expected '}' after requires signatures",
        .expected_requires_signatures_open_curly => "Expected '{' after requires signatures",
        .expect_closing_paren => "Expected closing parenthesis",
        .header_expected_open_square => "Expected '[' in header",
        .header_expected_close_square => "Expected ']' in header",
        .header_unexpected_token => "Unexpected token in header",
        .pattern_unexpected_token => "Unexpected token in pattern",
        .pattern_unexpected_eof => "Unexpected end of file in pattern",
        .ty_anno_unexpected_token => "Unexpected token in type annotation",
        .statement_unexpected_eof => "Unexpected end of file in statement",
        .statement_unexpected_token => "Unexpected token in statement",
        .string_unexpected_token => "Unexpected token in string",
        .string_expected_close_interpolation => "Expected end of string interpolation",
        .expr_if_missing_else => "If expression missing else clause",
        .expr_no_space_dot_int => "No space allowed between dot and integer",
        .import_exposing_no_open => "Expected '(' after exposing",
        .import_exposing_no_close => "Expected ')' after exposing",
        .no_else => "Missing else clause",
        .expected_type_field_name => "Expected type field name",
        .expected_colon_after_type_field_name => "Expected ':' after type field name",
        .expected_arrow => "Expected '->'",
        .expected_ty_close_curly_or_comma => "Expected '}' or ',' in type",
        .expected_ty_close_square_or_comma => "Expected ']' or ',' in type",
        .expected_lower_name_after_exposed_item_as => "Expected lowercase name after 'as'",
        .expected_upper_name_after_exposed_item_as => "Expected uppercase name after 'as'",
        .exposed_item_unexpected_token => "Unexpected token in exposed item",
        .expected_upper_name_after_import_as => "Expected uppercase name after import 'as'",
        .expected_colon_after_type_annotation => "Expected ':' after type annotation",
        .expected_lower_ident_pat_field_name => "Expected lowercase identifier in pattern field",
        .expected_colon_after_pat_field_name => "Expected ':' after pattern field name",
        .expected_expr_bar => "Expected '|' in expression",
        .expected_expr_close_curly_or_comma => "Expected '}' or ',' in expression",
        .expected_expr_close_round_or_comma => "Expected ')' or ',' in expression",
        .expected_expr_close_square_or_comma => "Expected ']' or ',' in expression",
        .expected_close_curly_at_end_of_match => "Expected '}' at end of match",
        .expected_open_curly_after_match => "Expected '{' after match",
        .expr_unexpected_token => "Unexpected token in expression",
        .expected_expr_record_field_name => "Expected record field name in expression",
        .expected_ty_apply_close_round => "Expected ')' in type application",
        .expected_ty_anno_end_of_function => "Expected end of function type annotation",
        .expected_ty_anno_end => "Expected end of type annotation",
        .expected_expr_apply_close_round => "Expected ')' in expression application",
        .where_expected_where => "Expected 'where'",
        .where_expected_mod_open => "Expected module opening in where clause",
        .where_expected_var => "Expected variable in where clause",
        .where_expected_mod_close => "Expected module closing in where clause",
        .where_expected_arg_open => "Expected argument opening in where clause",
        .where_expected_arg_close => "Expected argument closing in where clause",
        .where_expected_method_arrow => "Expected '->' in where clause method",
        .where_expected_method_or_alias_name => "Expected method or alias name in where clause",
        .where_expected_var_or_module => "Expected variable or module in where clause",
        .import_must_be_top_level => "Import must be at top level",
        .invalid_type_arg => "Invalid type argument",
        .expr_arrow_expects_ident => "Arrow expression expects identifier",
        .var_only_allowed_in_a_body => "Variable only allowed in function body",
        .var_must_have_ident => "Variable must have identifier",
        .var_expected_equals => "Expected '=' after variable",
        .for_expected_in => "Expected 'in' in for expression",
    };

    var report = reporting.Report.init(allocator, message, .runtime_error);

    // Add a note about the location - we can't easily extract source text without
    // resolving the TokenizedRegion, so just mention it's a parse error
    try report.addNote("This is a parse error. Check your syntax.");

    return report;
}
